<html><head><title>Cats MTL: Getting Started</title><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="Typelevel contributors" /><meta name="description" content="Monad Transformers made easy" /><meta name="og:image" content="/cats-mtl/img/poster.png" /><meta name="og:title" content="Cats MTL: Getting Started" /><meta name="og:site_name" content="Cats MTL" /><meta name="og:url" content="https://github.com/edmundnoble/cats-mtl" /><meta name="og:type" content="website" /><meta name="og:description" content="Monad Transformers made easy" /><link rel="icon" type="image/png" href="/cats-mtl/img/favicon.png" /><meta name="twitter:title" content="Cats MTL: Getting Started" /><meta name="twitter:image" content="https://github.com/edmundnoble/cats-mtlimg/poster.png" /><meta name="twitter:description" content="Monad Transformers made easy" /><meta name="twitter:card" content="summary_large_image" /><link rel="icon" type="image/png" sizes="16x16" href="/cats-mtl/img/favicon16x16.png" /><link rel="icon" type="image/png" sizes="24x24" href="/cats-mtl/img/favicon24x24.png" /><link rel="icon" type="image/png" sizes="32x32" href="/cats-mtl/img/favicon32x32.png" /><link rel="icon" type="image/png" sizes="48x48" href="/cats-mtl/img/favicon48x48.png" /><link rel="icon" type="image/png" sizes="57x57" href="/cats-mtl/img/favicon57x57.png" /><link rel="icon" type="image/png" sizes="60x60" href="/cats-mtl/img/favicon60x60.png" /><link rel="icon" type="image/png" sizes="64x64" href="/cats-mtl/img/favicon64x64.png" /><link rel="icon" type="image/png" sizes="70x70" href="/cats-mtl/img/favicon70x70.png" /><link rel="icon" type="image/png" sizes="72x72" href="/cats-mtl/img/favicon72x72.png" /><link rel="icon" type="image/png" sizes="76x76" href="/cats-mtl/img/favicon76x76.png" /><link rel="icon" type="image/png" sizes="96x96" href="/cats-mtl/img/favicon96x96.png" /><link rel="icon" type="image/png" sizes="114x114" href="/cats-mtl/img/favicon114x114.png" /><link rel="icon" type="image/png" sizes="120x120" href="/cats-mtl/img/favicon120x120.png" /><link rel="icon" type="image/png" sizes="128x128" href="/cats-mtl/img/favicon128x128.png" /><link rel="icon" type="image/png" sizes="144x144" href="/cats-mtl/img/favicon144x144.png" /><link rel="icon" type="image/png" sizes="150x150" href="/cats-mtl/img/favicon150x150.png" /><link rel="icon" type="image/png" sizes="152x152" href="/cats-mtl/img/favicon152x152.png" /><link rel="icon" type="image/png" sizes="196x196" href="/cats-mtl/img/favicon196x196.png" /><link rel="icon" type="image/png" sizes="310x310" href="/cats-mtl/img/favicon310x310.png" /><link rel="icon" type="image/png" sizes="310x150" href="/cats-mtl/img/favicon310x150.png" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" /><link rel="stylesheet" href="/cats-mtl/highlight/styles/atom-one-light.css" /><link rel="stylesheet" href="/cats-mtl/css/style.css" /><link rel="stylesheet" href="/cats-mtl/css/palette.css" /><link rel="stylesheet" href="/cats-mtl/css/codemirror.css" /></head><body><header id="site-header"><div class="navbar-wrapper navbar-inverse"><div class="container"><div class="navbar-header"><button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1" aria-expanded="false"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a href="/cats-mtl/" class="brand"><div class="icon-wrapper"><span>Cats MTL</span></div></a></div><nav class="text-right"><ul class=""><li><a href="https://github.com/typelevel/cats-mtl"><i class="fa fa-github"></i><span class="hidden-xs">GitHub</span></a></li><li><a href="api"><i class="fa fa-file-text"></i><span class="hidden-xs">Scaladoc</span></a></li></ul></nav></div></div><div class="jumbotron" style="background-image:url('/cats-mtl/img/jumbotron_pattern.png')"></div><div><ul class="horizontalNav">                     <li><a class="" href="/cats-mtl/">Home</a></li>  <li><a class=" active " href="/cats-mtl/getting-started.html">Getting Started</a></li>  <li><a class="" href="/cats-mtl/mtl-classes.html">MTL Type Classes</a></li>  <li><a class="" href="/cats-mtl/lifting-classes.html">Lifting Classes</a></li>  <li><a class="" href="/cats-mtl/migration.html">Migration Guide</a></li>  <li><a class="" href="/cats-mtl/design.html">Design</a></li>  <li><a class="" href="/cats-mtl/contributing.html">Contributing</a></li> </ul></div></header><main id="site-main"><section class="use"><div class="container"><div id="content"><h2 id="what-is-mtl">What is MTL?</h2>

<p>Mtl is an acronym and stands for Monad Transformer Library. 
It’s main purpose it make it easier to work with nested monad transformers. 
It achieves this by encoding the effects of most common monad transformers as type classes.</p>

<h3 id="the-problem">The problem</h3>

<p>Have you ever worked with two or more monad transformers nested inside each other?
If you haven’t, working with what some call <strong>monad transformer stacks</strong> can be incredibly painful.
This is because, the more monad transformers you add to your stack the more type parameters the type system has to deal with and the worse type inference gets.
For example, here’s a small example of a method that modifies reads the current state in <code class="highlighter-rouge">StateT</code> and raises an error using <code class="highlighter-rouge">EitherT</code>:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.data._</span>
<span class="c1">// import cats.data._
</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>
<span class="c1">// import cats.implicits._
</span>
<span class="k">def</span> <span class="n">checkState</span><span class="k">:</span> <span class="kt">EitherT</span><span class="o">[</span><span class="kt">StateT</span><span class="o">[</span><span class="kt">List</span>, <span class="kt">Int</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">Exception</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">currentState</span> <span class="k">&lt;-</span> <span class="nc">EitherT</span><span class="o">.</span><span class="n">liftF</span><span class="o">(</span><span class="nc">StateT</span><span class="o">.</span><span class="n">get</span><span class="o">[</span><span class="kt">List</span>, <span class="kt">Int</span><span class="o">])</span>
  <span class="n">result</span> <span class="k">&lt;-</span> <span class="k">if</span> <span class="o">(</span><span class="n">currentState</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="o">)</span> 
              <span class="nc">EitherT</span><span class="o">.</span><span class="n">leftT</span><span class="o">[</span><span class="kt">StateT</span><span class="o">[</span><span class="kt">List</span>, <span class="kt">Int</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">String</span><span class="o">](</span><span class="k">new</span> <span class="nc">Exception</span><span class="o">)</span>
            <span class="k">else</span> 
              <span class="nc">EitherT</span><span class="o">.</span><span class="n">rightT</span><span class="o">[</span><span class="kt">StateT</span><span class="o">[</span><span class="kt">List</span>, <span class="kt">Int</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">Exception</span><span class="o">](</span><span class="s">"All good"</span><span class="o">)</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">result</span>
<span class="c1">// checkState: cats.data.EitherT[[γ$0$]cats.data.IndexedStateT[[+A]List[A],Int,Int,γ$0$],Exception,String]
</span></code></pre></div></div>

<p>There’s a bunch of type annotations and extra machinery that really has nothing to do with the actual progam and this problem only gets worse as you add more expressions to your for-comprehension or add an additional monad transformer to the stack.</p>

<p>Thankfully, Cats-mtl is here to help.</p>

<h2 id="how-cats-mtl-helps">How Cats-mtl helps</h2>

<h3 id="monad-transformers-encode-some-notion-of-effect">Monad Transformers encode some notion of <em>effect</em></h3>

<p><code class="highlighter-rouge">EitherT</code> encodes the effect of short-circuiting errors.
<code class="highlighter-rouge">ReaderT</code> encodes the effect of reading a value from the environment.
<code class="highlighter-rouge">StateT</code> encodes the effect of pure local mutable state.</p>

<p>All of these monad transformers encode their effects as data structures, but there’s another way to achieve the same result: Type classes!</p>

<p>For example take <code class="highlighter-rouge">ReaderT.ask</code> function, what would it look like if we used a type class here instead?
Well, Cats-mtl has an answer and it’s called <code class="highlighter-rouge">ApplicativeAsk</code>.
You can think of it as <code class="highlighter-rouge">ReaderT</code> encoded as a type class:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">trait</span> <span class="nc">ApplicativeAsk</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]</span>, <span class="kt">E</span><span class="o">]</span> <span class="o">{</span>
  <span class="k">val</span> <span class="n">applicative</span><span class="k">:</span> <span class="kt">Applicative</span><span class="o">[</span><span class="kt">F</span><span class="o">]</span>

  <span class="k">def</span> <span class="n">ask</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">E</span><span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div>

<p>At it’s core <code class="highlighter-rouge">ApplicativeAsk</code> just encodes the fact that we can ask for a value from the environment, exactly like <code class="highlighter-rouge">ReaderT</code> does.
Exactly like <code class="highlighter-rouge">ReaderT</code>, it also includes another type parameter <code class="highlighter-rouge">E</code>, that represents that environment.</p>

<p>If you’re wondering why <code class="highlighter-rouge">ApplicativeAsk</code> has an <code class="highlighter-rouge">Applicative</code> field instead of just extending from <code class="highlighter-rouge">Applicative</code>, that is to avoid implicit ambiguities that arise from having multiple subclasses of a given type (here <code class="highlighter-rouge">Applicative</code>) in scope implicitly.
So in this case we favor composition over inheritance as otherwise, we could not e.g. use <code class="highlighter-rouge">Monad</code> together with <code class="highlighter-rouge">ApplicativeAsk</code>.</p>

<p><code class="highlighter-rouge">ApplicativeAsk</code> is an example for what is at the core of Cats-mtl.
Cats-mtl provides type classes for most common effects which let you choose what kind of effects you need without commiting to a specific monad transformer stack.</p>

<p>Ideally, you’d write all your code using only an abstract type constructor <code class="highlighter-rouge">F[_]</code> with different type class constraints and then at the end run that code with a specific data type that is able to fulfill those constraints.
So without further ado, let’s look at what the program from earlier looks when using Cats-mtl:</p>

<p>First, the original program again:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.data._</span>
<span class="c1">// import cats.data._
</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>
<span class="c1">// import cats.implicits._
</span>
<span class="k">def</span> <span class="n">checkState</span><span class="k">:</span> <span class="kt">EitherT</span><span class="o">[</span><span class="kt">StateT</span><span class="o">[</span><span class="kt">List</span>, <span class="kt">Int</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">Exception</span>, <span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">currentState</span> <span class="k">&lt;-</span> <span class="nc">EitherT</span><span class="o">.</span><span class="n">liftF</span><span class="o">(</span><span class="nc">StateT</span><span class="o">.</span><span class="n">get</span><span class="o">[</span><span class="kt">List</span>, <span class="kt">Int</span><span class="o">])</span>
  <span class="n">result</span> <span class="k">&lt;-</span> <span class="k">if</span> <span class="o">(</span><span class="n">currentState</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="o">)</span> 
              <span class="nc">EitherT</span><span class="o">.</span><span class="n">leftT</span><span class="o">[</span><span class="kt">StateT</span><span class="o">[</span><span class="kt">List</span>, <span class="kt">Int</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">String</span><span class="o">](</span><span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="s">"Too large"</span><span class="o">))</span>
            <span class="k">else</span> 
              <span class="nc">EitherT</span><span class="o">.</span><span class="n">rightT</span><span class="o">[</span><span class="kt">StateT</span><span class="o">[</span><span class="kt">List</span>, <span class="kt">Int</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">Exception</span><span class="o">](</span><span class="s">"All good"</span><span class="o">)</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">result</span>
<span class="c1">// checkState: cats.data.EitherT[[γ$0$]cats.data.IndexedStateT[[+A]List[A],Int,Int,γ$0$],Exception,String]
</span></code></pre></div></div>

<p>And now the mtl version:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nn">cats.MonadError</span>
<span class="c1">// import cats.MonadError
</span>
<span class="k">import</span> <span class="nn">cats.implicits._</span>
<span class="c1">// import cats.implicits._
</span>
<span class="k">import</span> <span class="nn">cats.mtl.implicits._</span>
<span class="c1">// import cats.mtl.implicits._
</span>
<span class="k">import</span> <span class="nn">cats.mtl.MonadState</span>
<span class="c1">// import cats.mtl.MonadState
</span>
<span class="k">def</span> <span class="n">checkState</span><span class="o">[</span><span class="kt">F</span><span class="o">[</span><span class="k">_</span><span class="o">]](</span><span class="k">implicit</span> <span class="n">S</span><span class="k">:</span> <span class="kt">MonadState</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Int</span><span class="o">],</span> <span class="n">E</span><span class="k">:</span> <span class="kt">MonadError</span><span class="o">[</span><span class="kt">F</span>, <span class="kt">Exception</span><span class="o">])</span><span class="k">:</span> <span class="kt">F</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
  <span class="n">currentState</span> <span class="k">&lt;-</span> <span class="n">S</span><span class="o">.</span><span class="n">get</span>
  <span class="n">result</span> <span class="k">&lt;-</span> <span class="k">if</span> <span class="o">(</span><span class="n">currentState</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="o">)</span> <span class="n">E</span><span class="o">.</span><span class="n">raiseError</span><span class="o">(</span><span class="k">new</span> <span class="nc">Exception</span><span class="o">(</span><span class="s">"Too large"</span><span class="o">))</span>
            <span class="k">else</span> <span class="n">E</span><span class="o">.</span><span class="n">pure</span><span class="o">(</span><span class="s">"All good"</span><span class="o">)</span>
<span class="o">}</span> <span class="k">yield</span> <span class="n">result</span>
<span class="c1">// checkState: [F[_]](implicit S: cats.mtl.MonadState[F,Int], implicit E: cats.MonadError[F,Exception])F[String]
</span></code></pre></div></div>

<p>We’ve reduced the boilerplate immensly!
Now our small program actually looks just like control flow and we didn’t need to annotate any types.</p>

<p>This is great so far, but <code class="highlighter-rouge">checkState</code> now returns an abstract <code class="highlighter-rouge">F[String]</code>.
We need some <code class="highlighter-rouge">F</code> that has an instance of both <code class="highlighter-rouge">MonadState</code> and <code class="highlighter-rouge">MonadError</code>.
We know that <code class="highlighter-rouge">EitherT</code> can have a <code class="highlighter-rouge">MonadError</code> instance and <code class="highlighter-rouge">StateT</code> can have a <code class="highlighter-rouge">MonadState</code> instance, but how do we get both?
Fortunately, cats-mtl allows us to lift instances of mtl classes through our monad transformer stack.
That means, that e.g. <code class="highlighter-rouge">EitherT[StateT[List, Int, ?], Exception, A]</code> has both the <code class="highlighter-rouge">MonadError</code> and <code class="highlighter-rouge">MonadState</code> instances we need, neat!</p>

<p>So let’s try turning our abstract <code class="highlighter-rouge">F[String]</code> into an actual value:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">val</span> <span class="n">materializedProgram</span> <span class="k">=</span>
  <span class="n">checkState</span><span class="o">[</span><span class="kt">EitherT</span><span class="o">[</span><span class="kt">StateT</span><span class="o">[</span><span class="kt">List</span>, <span class="kt">Int</span>, <span class="kt">?</span><span class="o">]</span>, <span class="kt">Exception</span>, <span class="kt">?</span><span class="o">]]</span>
</code></pre></div></div>

<p>This process of turning a program defined by an abstract type constructor with additional type class constraints into an actual concrete data type is sometimes called <em>interpreting</em> or <em>materializing</em>  a program.
Usually we don’t have to do this until the very end where we want to run the full application, so the only places we see actual monad transformers at the very edge.</p>

<p>In summary Cats-mtl provides two things:
MTL type classes representing effects and a way to lift instances of these classes through transformer stacks.</p>

<p>We suggest you start learning the MTL classes first and learn how lifting works later, as you don’t need to understand lifting at all to enjoy all the benefits of Cats-mtl.</p>

<h4 id="available-mtl-classes">Available MTL classes</h4>

<p>cats-mtl provides the following “MTL classes”:</p>
<ul>
  <li><a href="mtl-classes/applicativeask.html">ApplicativeAsk</a></li>
  <li><a href="mtl-classes/applicativelocal.html">ApplicativeLocal</a></li>
  <li><a href="mtl-classes/functorraise.html">FunctorRaise</a></li>
  <li><a href="mtl-classes/applicativehandle.html">ApplicativeHandle</a></li>
  <li><a href="mtl-classes/functortell.html">FunctorTell</a></li>
  <li><a href="mtl-classes/functorlisten.html">FunctorListen</a></li>
  <li><a href="mtl-classes/monadstate.html">MonadState</a></li>
  <li><a href="mtl-classes/monadchronicle.html">MonadChronicle</a></li>
</ul>

<p>If you’re wondering why some of these are based on <code class="highlighter-rouge">Monad</code> and others on <code class="highlighter-rouge">Functor</code> or <code class="highlighter-rouge">Applicative</code>, 
 it is because these are the smallest superclass dependencies practically possible with which you can define their laws.
This is in contrast to Haskell’s <code class="highlighter-rouge">mtl</code> library and earlier versions of Cats as well as Scalaz,
 this gives us less restrictions over which type classes can be lifted over which transformers.</p>

<p>Because these type classes are commonly combined, the base typeclasses are ambiguous in implicit scope using
the typical cats subclass encoding via inheritance.
Thus in cats-mtl, the ambiguity is avoided by using the composition approach that we saw with <code class="highlighter-rouge">ApplicativeAsk</code> earlier.
In a future version of Scala we might be able to avoid this and have the same type class encoding everywhere.</p>
</div></div></section></main><footer id="site-footer"><div class="container"><div class="row"><div class="col-xs-6"><p>Cats MTL is designed and developed by <a href="https://github.com/edmundnoble/cats-mtl" target="_blank">Typelevel contributors</a></p></div><div class="col-xs-6"><p class="text-right"><a href="https://github.com/typelevel/cats-mtl"><span class="fa fa-github"></span>View on GitHub</a></p></div></div><div class="row"><div class="col-xs-6"><p>Website built with <a href="https://47deg.github.io/sbt-microsites/" target="_blank">Sbt-microsites</a> - © 2016 <a href="https://www.47deg.com/" target="_blank">47 Degrees</a></p></div></div></div></footer><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="/cats-mtl/highlight/highlight.pack.js"></script><script>hljs.configure({languages:['scala','java','bash']});
hljs.initHighlighting();
              </script><script>((window.gitter = {}).chat = {}).options = {
room: 'typelevel/cats-mtl'};</script><script src="https://sidecar.gitter.im/dist/sidecar.v1.js"></script></body></html>